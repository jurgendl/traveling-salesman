<!DOCTYPE html>
<html lang="en">
<!--
	https://en.wikipedia.org/wiki/Graph_theory
	https://mathjs.org/docs/datatypes/matrices.html
	https://cdnjs.com/libraries/mathjs

	https://www.youtube.com/watch?v=BAejnwN4Ccw&ab_channel=TheCodingTrain
-->

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Traveling Salesman</title>
	<link rel="stylesheet" href="traveling-salesman.css">
	<style type="text/css">

	</style>
</head>

<body>
	<h1>Traveling Salesman</h1>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.9.1/math.js" integrity="sha512-iC7V/1gOwGXzYGJ9f860Jq9K/YrL+AsSI7k/03F98EkX1GEsP2VjWdHgWpwhinDTe+HGznwCnVdR2d/o2In9bA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
	<script src="traveling-salesman.js"></script>

	<!--<script src="http://d3js.org/d3.v3.min.js"></script>-->
	<script src="https://d3js.org/d3.v4.min.js"></script>

	<div id="my_dataviz"></div>

	<script>
		const graph = new Graph();
		{
			const randomNodes = 20;
			const randomEdges = 40;
			for (var i = 0; i < randomNodes; i++) {
				graph.addVertex('' + i);
			}
			for (var i = 0; i < randomEdges; i++) {
				const startpoint = graph.vertices[Math.floor(Math.random() * graph.vertices.length)];
				const endpoint = graph.vertices[Math.floor(Math.random() * graph.vertices.length)];
				graph.addEdge(startpoint, endpoint, Math.random() * 10);
			}
		}

		function convert(g) {
			const data = {};
			data.nodes = [];
			data.links = [];
			for (var i = 0; i < g.vertices.length; i++) {
				var vertex = g.vertices[i];
				data.nodes.push({ id: g.indexOfVertex(vertex), name: vertex.name });
			}
			for (var i = 0; i < g.edges.length; i++) {
				var edge = g.edges[i];
				data.links.push({ source: g.indexOfVertex(edge.startpoint), target: g.indexOfVertex(edge.endpoint) });
			}
			return data;
		}

		const data = convert(graph);

		console.log(graph);
		console.log(JSON.stringify(data, null, "\t"));

		// set the dimensions and margins of the graph
		var margin = { top: 30, right: 30, bottom: 30, left: 30 },
			width = 1024 - margin.left - margin.right,
			height = 1920 - margin.top - margin.bottom;

		// append the svg object to the body of the page
		var svg = d3.select("#my_dataviz")
			.append("svg")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

		// Initialize the links
		var link = svg
			.selectAll("line")
			.data(data.links)
			.enter()
			.append("line")
			.style("stroke", "#aaa")

		// Initialize the nodes
		var node = svg
			.selectAll("circle")
			.data(data.nodes)
			.enter()
			.append("circle")
			.attr("r", 6)
			.style("fill", "#69b3a2")
			/*.call(d3.drag()
				.on("start", dragstarted)
				.on("drag", dragged)
				.on("end", dragended))*/;

		var label = svg.append("g")
			.attr("class", "labels")
			.selectAll("text")
			.data(data.nodes)
			.enter().append("text")
			.attr("class", "label")
			.text(function (d) { return d.name; });

		// Let's list the force we wanna apply on the network
		var simulation = d3.forceSimulation(data.nodes)
			// Force algorithm is applied to data.nodes
			.force("link", d3.forceLink()
				// This force provides links between nodes
				.id(function (d) { return d.id; })
				// This provide  the id of a node
				.links(data.links)
				// and this the list of links
			)
			.force("charge", d3.forceManyBody().strength(-800))
			// This adds repulsion between nodes. Play with the -400 for the repulsion strength
			.force("center", d3.forceCenter(width / 2, height / 2))
			// This force attracts nodes to the center of the svg area
			.on("end", ticked);

		// This function is run at each iteration of the force algorithm, updating the nodes position.
		function ticked() {
			link
				.attr("x1", function (d) { return d.source.x; })
				.attr("y1", function (d) { return d.source.y; })
				.attr("x2", function (d) { return d.target.x; })
				.attr("y2", function (d) { return d.target.y; });

			node
				.attr("cx", function (d) { return d.x; })
				.attr("cy", function (d) { return d.y; });
			label
				.attr("x", function (d) { return d.x - 4; })
				.attr("y", function (d) { return d.y - 10; })
				.style("font-size", "14px")
				.style("font-weight", "700")
				.style("fill", "#000");
		}

		/*function dragstarted(d) {
			if (!d3.event.active) simulation.alphaTarget(0.3).restart()
			simulation.fix(d);
		}

		function dragged(d) {
			simulation.fix(d, d3.event.x, d3.event.y);
		}

		function dragended(d) {
			if (!d3.event.active) simulation.alphaTarget(0);
			simulation.unfix(d);
		}*/



		/*
		var w = 1000;
		var h = 600;
		var linkDistance = 200;
		var colors = d3.scale.category10();
		var dataset = { nodes: [], edges: [] };
		console.log(graph.vertices.length);
		for (var i = 0; i < graph.vertices.length; i++) {
			var vertex = graph.vertices[i];
			dataset.nodes.push({ name: vertex.name });
		}
		console.log(graph.edges.length);
		for (var i = 0; i < graph.edges.length; i++) {
			var edge = graph.edges[i];
			dataset.edges.push({ source: graph.indexOfVertex(edge.startpoint), target: graph.indexOfVertex(edge.endpoint) });
		}
		console.log(dataset);

		var svg = d3.select("content").append("svg").attr({ "width": w, "height": h });

		var force = d3.layout.force()
			.nodes(dataset.nodes)
			.links(dataset.edges)
			.size([w, h])
			.linkDistance([linkDistance])
			.charge([-500])
			.theta(0.1)
			.gravity(0.05)
			.start();


		var edges = svg.selectAll("line")
			.data(dataset.edges)
			.enter()
			.append("line")
			.attr("id", function (d, i) { return 'edge' + i })
			.attr('marker-end', 'url(#arrowhead)')
			.style("stroke", "#ccc")
			.style("pointer-events", "none");

		var nodes = svg.selectAll("circle")
			.data(dataset.nodes)
			.enter()
			.append("circle")
			.attr({ "r": 15 })
			.style("fill", function (d, i) { return colors(i); })
			.call(force.drag)


		var nodelabels = svg.selectAll(".nodelabel")
			.data(dataset.nodes)
			.enter()
			.append("text")
			.attr({
				"x": function (d) { return d.x; },
				"y": function (d) { return d.y; },
				"class": "nodelabel",
				"stroke": "black"
			})
			.text(function (d) { return d.name; });

		var edgepaths = svg.selectAll(".edgepath")
			.data(dataset.edges)
			.enter()
			.append('path')
			.attr({
				'd': function (d) { return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y },
				'class': 'edgepath',
				'fill-opacity': 0,
				'stroke-opacity': 0,
				'fill': 'blue',
				'stroke': 'red',
				'id': function (d, i) { return 'edgepath' + i }
			})
			.style("pointer-events", "none");

		var edgelabels = svg.selectAll(".edgelabel")
			.data(dataset.edges)
			.enter()
			.append('text')
			.style("pointer-events", "none")
			.attr({
				'class': 'edgelabel',
				'id': function (d, i) { return 'edgelabel' + i },
				'dx': 80,
				'dy': 0,
				'font-size': 10,
				'fill': '#aaa'
			});

		edgelabels.append('textPath')
			.attr('xlink:href', function (d, i) { return '#edgepath' + i })
			.style("pointer-events", "none")
			.text(function (d, i) { return 'label ' + i });


		svg.append('defs').append('marker')
			.attr({
				'id': 'arrowhead',
				'viewBox': '-0 -5 10 10',
				'refX': 25,
				'refY': 0,
				//'markerUnits':'strokeWidth',
				'orient': 'auto',
				'markerWidth': 10,
				'markerHeight': 10,
				'xoverflow': 'visible'
			})
			.append('svg:path')
			.attr('d', 'M 0,-5 L 10 ,0 L 0,5')
			.attr('fill', '#ccc')
			.attr('stroke', '#ccc');


		force.on("tick", function () {

			edges.attr({
				"x1": function (d) { return d.source.x; },
				"y1": function (d) { return d.source.y; },
				"x2": function (d) { return d.target.x; },
				"y2": function (d) { return d.target.y; }
			});

			nodes.attr({
				"cx": function (d) { return d.x; },
				"cy": function (d) { return d.y; }
			});

			nodelabels.attr("x", function (d) { return d.x; })
				.attr("y", function (d) { return d.y; });

			edgepaths.attr('d', function (d) {
				var path = 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y;
				//console.log(d)
				return path
			});

			edgelabels.attr('transform', function (d, i) {
				if (d.target.x < d.source.x) {
					bbox = this.getBBox();
					rx = bbox.x + bbox.width / 2;
					ry = bbox.y + bbox.height / 2;
					return 'rotate(180 ' + rx + ' ' + ry + ')';
				}
				else {
					return 'rotate(0)';
				}
			});
		});
		*/
	</script>
</body>

</html>